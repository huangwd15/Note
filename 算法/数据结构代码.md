# 数据结构代码

## 1.稀疏数组

当一个数组中大部分元素为0或者同为一个值时，可以用稀疏数组保存。即只记录不同的值。

第一个值一般记录原始大小。

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
)

const (
	BLACK_CHESS = 1 // 黑子
	WIHTE_CHESS = 2 // 白子
	FILE_NAME = "data.json"
)

type ValNode struct {
	Row int `json:"row"`
	Col int `json:"col"`
	Val int `json:"val"`
}


// 稀疏数组
func main() {
	var chessMap [10][10]int
	chessMap[1][5] = BLACK_CHESS
	chessMap[2][3] = WIHTE_CHESS
	chessMap[4][6] = BLACK_CHESS
	chessMap[7][9] = WIHTE_CHESS

	for _, v := range chessMap {
		for _, v2 := range v {
			fmt.Printf("%d\t", v2)
		}
		fmt.Println()
	}

	var sparseArr []ValNode
	// 第一个结构体记录原始数组的大小
	sparseArr = append(sparseArr, ValNode{Row: len(chessMap), Col: len(chessMap[0]), Val: 0})
	for r, v := range chessMap {
		for c, v2 := range v {
			if v2 != 0 {
				valNode := ValNode{Row: r, Col: c, Val: v2}
				sparseArr = append(sparseArr, valNode)
			}
		}
	}
	// 打印
	for _, node := range sparseArr {
		fmt.Println(node)
	}
	// 存到文件,用json格式
	j, err := json.Marshal(sparseArr)
	if err != nil {
		fmt.Println(err)
		return
	}
	err = ioutil.WriteFile(FILE_NAME, j, 0666)
	if err != nil {
		fmt.Println(err)
		return
	}
	// 恢复
	b, err := ioutil.ReadFile(FILE_NAME)
	if err != nil {
		fmt.Println(err)
		return
	}
	var sparseSlice []ValNode
	err = json.Unmarshal(b, &sparseSlice)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println("恢复后的棋盘")
	for _, sp := range sparseSlice {
		fmt.Println(sp)
	}

}
```

