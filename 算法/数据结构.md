- [数据结构](#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84)
  - [1 列表](#1-%e5%88%97%e8%a1%a8)
  - [2 数组](#2-%e6%95%b0%e7%bb%84)
  - [3 栈](#3-%e6%a0%88)
  - [4 队列](#4-%e9%98%9f%e5%88%97)
  - [5 哈希表](#5-%e5%93%88%e5%b8%8c%e8%a1%a8)
  - [6 堆](#6-%e5%a0%86)
  - [7 二叉树查找](#7-%e4%ba%8c%e5%8f%89%e6%a0%91%e6%9f%a5%e6%89%be)
  - [8 集合](#8-%e9%9b%86%e5%90%88)

# 数据结构

## 1 链表

链表可以存储多个值，它的特点是将数据与指标配对，以及指向下一条数据的内存位置。

在链表中，数据存储在内存中分散的位置，所以每个数据只能通过前面的指标访问。

添加数据只需要将上一个数据的指向新数据，新数据再指向下一个。

链表分为单向链表、双向链表、环形链表和静态链表。

> 静态链表就是用连续内存保存链表数据，同时有指向下一个地址的参数。

使用场景：表长难以预估，经常要增加删除元素

## 2 数组

数组可以存储多个值，通过索引访问。

数组中的数据存储在连续位置的存储器中。

添加元素时，要确保数组末尾有额外空间，然后一个一个移动数据，腾出要添加的位置；删除元素则相反，先删除元素，移动数据填补空白区域，最后删除额外的空间。

总结：

数组查找很快，通过索引直接找到，但是增加和删除很慢，需要移动其他数据位置。

表长可预估，查询操作较多。

## 3 栈

就想往一个盒子里放CD，先进后出。

可以用数组实现，也可以用链表实现。

栈用一个辅助指针。

## 4 队列

类似排队，先进先出。

栈和队列的本质也是数组，不过增加了约束条件。

队列用两个辅助指针。一个指向头，一个指向尾。

判断空和满，可以使用辅助变量或者。

双端队列，可以从两端插入和删除。

## 5 哈希表 

以key和value组成键值对，然后准备一个数组，将键值对的哈希值取数组长度的余，放入数组中，如果有相同的余数，则放入列表里，这样可以快速访问数据，不过要谨慎使用。

## 6 堆

堆是一种树形结构，并在实现 **优先队列** 时使用。

优先队列可以按任意顺序添加数据，取出时选择最小值。

过程：

1. 添加的数字放在末尾；
2. 如果父类数字比较大，则子类与父类互换；
3. 以此类推，直到不发生替换；
4. 取出数字时，从最上面的数字取出；
5. 将结尾的数字移动到顶部；
6. 重新开始比较子类与父类，直到不发生替换为止

使用堆可以快速取出最小的数据，但是无法执行在树中间取出数据的操作。

## 7 二叉树查找

二叉树有两个属性：第一个是所有节点都比左子树大，第二个是所有节点都比右子树小。

添加节点：从顶端节点开始，逐个比较，放到合适位置。

删除节点：

1. 如果没有子节点直接删除；
2. 如果有一个子节点，移动子节点到删除的位置；
3. 有两个子节点，可以从左子树中找最大的节点移动到删除的位置，也可以找右子树最小值。

一直保持良好平衡的二叉树称为 `自平衡二叉树` ，能保持搜索效率。

## 8 集合

一种不允许重复元素的数据结构。

这也是和数组最大的区别。所以它的插入比一般的数组慢。