# 操作系统

## 特征

- 并发
- 共享：资源共享
- 虚拟：把物理上的实体变为若干个逻辑上的对应物，使用"时分复用技术"
- 异步：允许多个程序并发执行，进程走走停停，不可预知的速度向前

> 并发：多个事件在单位时间内发生；并行：同一时间发生。

## 中断

中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。

有了中断才能让程序并发执行。

## 进程

每创建一个进程，系统会分配4G虚拟内存，包括3G用户内存和1G内核内存。

内核内存对所有进程共享，所以绝大多数进程间通信的本质都是对内核空间的操作。

五种状态：

- 创建态
- 就绪态
- 运行态
- 阻塞态
- 终止态

使用PCB管理进程，PCB里记录了改进程的状态、比如程序指针、变量指针和状态标志等等。

用原语控制进程，即原子操作，执行期间不允许中断。采用关中断和开中断指令实现。

进程拥有的内存地址相互独立。一个进程不能访问另一个进程的内存地址。

进程通信：

- 共享内存：进程访问必须互斥
- 管道通信：其实就是在内存中开辟一个大小固定的缓冲区，管道只能半双工通信，所以需要两个管道，写满时不能写，读空时不能读
- 消息传递：发送格式化消息，直接挂到接收方消息队列，或者发送到中间体（信箱）

具体方式：

- 管道：有名管道，无名管道
- 信号：本质是中断
- 消息队列
- 共享内存：效率最高，直接操作物理内存 
- 信号量
- socket

## 信号

信号是软件层次上的中断机制，是一种异步通信。通过发送信号（应该是改变内核内存中的变量）操作进程，比如停止。

发送信号的函数：

- kill：给指定进程立即发送信号
- alarm：在一段时间后发送信号
- raise：给本进程立即发送信号
- 信号集等

## 线程

有的进程需要"同时"做很多事，所以引入了线程，作为执行流的最小单位。

实现方式：

用户级线程，由应用程序通过线程库实现。

内核级线程，由操作系统内核完成。

在同时支持用户级线程和内核级线程的系统中，可采用二者组合方式，将n个用户线程映射到m个内核级线程上。

## 进程互斥

### 单标志法

使用一个标志位用于判断是否能使用临界区

### 双标志先检查

设置布尔型数组，每个进程对应一个元素， 各进程想进入临界区之前先将自己的标志位置为true，访问完后再置为false。

### 双标志后检查

### Peterson算法

结合双标志位和单标志位，即数组和一个标志位。

## 信号量机制

整型信号量、记录型信号量

信号量就是一个变量，表示系统中某种资源的数量。可以用整数，也可以用结构体。

## 生产者消费者

生产者生成的数据放入缓冲区，消费者从中取出。

缓冲区时临界资源，必须互斥的访问。

## 管程

一种高级同步机制，比信号量更高级。更方便的实现进程互斥和同步。

Java中的synchronized就是管程机制。

## 死锁

在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都在阻塞的现象。

## 内存管理

1. 内存空间的分配于回收
2. 虚拟内存
3. 地址转换
4. 内存保护

覆盖技术，解决程序大小超过物理呢村总和的问题。将程序分为多个段，常用的段常驻内存，不常用的段再需要时调入内存。

分为一个固定区和若干个覆盖区。

交换技术：内存空间紧张时，将内存中某些进程暂时换出外存，把已经具备运行条件的进程换入内存。

**动态分区分配**

根据进程的大小动态的简历分区，并使分区的大小正好适合进程的需要。

分配算法：

- 首次适应
- 最佳适应
- 最坏适应
- 邻近适应

**非连续分配管理方式**

- 基本分页存储管理：把内存分为一个个相等的小分区，再按照分区把进程拆分成小部分
- 基本分段存储管理
- 段页式存储管理

## 文件

- 无结构文件：文本文件
- 有结构文件：顺序文件、索引文件、索引数序文件

