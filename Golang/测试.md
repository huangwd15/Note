# 测试

有三种测试方式：

- 功能测试
- 压力测试
- 测试代码覆盖率的测试

## 测试用例规则

1. 测试文件命名必须以 `_test.go` 结尾，比如：`main_test.go`
2. 函数名必须以 `Test` 开头,后头跟着的函数名不能以小写字母开头,比如：`TestCbs`
3. 函数的参数：`*testing.T`
4. 导入需要的包: `import testing`

举例：

```go
package main

import (
	"testing"
)

func TestMain(t *testing.T) {
    // 读取
	hs, err := readHistroty()
	if err != nil {
		t.Error(err)
	}
	if len(hs) != 0 {
		t.Error("read history failed:", hs)
	}
}

```

`testing.T` 拥有几个非常有用的函数

- `Log`: 记录到错误日志
- `Logf`: 格式化输出到日志
- `Fail`: 将函数标记为 "已失败"，但允许继续执行
- `FailNow`: 将函数标记为 "已失败"，并停止执行

还提供了由以上几个函数组合而成的便利函数

| | Log | Logf |
|--|--|--|
| Fail | Error | Errorf |
| FailNow | Fatal | Fatalf |

`Error`会先后调用Log和Fail

`Fatal`则先后调用Log和FailNow

## 跳过测试用例

有两种方式

- t.Skip()
- short

举例：

```go
func LongGo() {
	time.Sleep(10 * time.Second)
	log.Println("long go")
}
```

```go
func TestLongGo(t *testing.T) {
	t.Skip()
}
```

结果：

```
go test -v
=== RUN   TestLog
--- PASS: TestLog (0.00s)
=== RUN   TestLongGo
--- SKIP: TestLongGo (0.00s)
    main_test.go:25: 
```

而 `-short`标志会根据用户编写测试代码的方式，选择性跳过部分

举例：

```go
func TestTimeConsuming(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping test in short mode.")
    }
    ...
}
```

执行的时候加上参数

	go test -v - short

## TestMain

相当于 `setup` 和 `teardown`

会先执行 `func TestMain(m *testing.M)` 函数，我们可以在该函数里执行其他操作

举例：

func TestMain(m *testing.M) {
	// 在测试之前的操作
	os.Exit(m.Run())
	// 如果需要在测试之后操作，则调用 m.Run()
} 

## 功能测试（单元测试）

