# 基础_5

## interface

interface就是一组抽象方法的集合，它必须由其他非interface类型实现，其他非interface类型实现之后就可以被当做该接口类型

```go
package main

import "fmt"

type Human struct {
	name  string
	age   int
	phone string
}

func (h Human) sayHello(name string) {
	fmt.Printf("Hello %s, this is %s", name, h.name)
}

type Man interface {
	sayHello(name string)
}

func main() {
    h := Human{name: "Ren", age: 28, phone: "18673298768"}
    //Human 能转换成 Man 类型
	var m Man
	m = h
	m.sayHello("Lang")
}
```

> 这点和Java是一样的，实现了某个接口就可以转换为接口类型

举例Java：

```java
public class Main {

    public static void main(String[] args) {
        My my = new My();
        sayHi(my);
    }

    private static void sayHi(Man m) {
        m.sayHello("Lang");
    }
}
```

```java
public class My implements Man {


    @Override
    public void sayHello(String name) {
        System.out.printf("Hello %s", name);
    }
}

```

```java
public interface Man {

    void sayHello(String name);
}
```

输出：Hello Lang

### 空interface

空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface

```go
// 定义a为空接口
var a interface{}
var i int = 5
s := "Hello world"
// a可以存储任意类型的数值
a = i
a = s
```

> 和Java里的 Object 类型基本相同

### interface函数参数

interface的变量可以持有任意实现该interface类型的对象，可以通过定义interface参数，让函数接受各种类型的参数。

举例： 自定义实现`fmt.Println`

```go
package main

import "fmt"

type Human struct {
	name  string
	age   int
	phone string
}

//func (h Human) String() string {
//	return "<h.name=" + h.name + "-h.phone=" + h.phone + ">"
//}

func main() {
	h := Human{name: "Ren", age: 28, phone: "18673298768"}
	fmt.Println(h)
}
```

正常情况输出：

    {Ren 28 18673298768}

实现了`String`接口后输出：

    <h.name=Ren-h.phone=18673298768>